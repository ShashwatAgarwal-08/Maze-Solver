# Maze-Solver
Design and analyze an efficient maze-solving algorithm using principles of design analysis and algorithmic techniques. The algorithm should be capable of finding the shortest path from a starting point to the endpoint within a given maze. Through rigorous analysis, evaluate the algorithm's performance in terms of time complexity, space complexity, and scalability. This project aims to develop a robust maze solver with applications in various domains, such as robotics, gaming, and navigation, emphasizing the importance of effective algorithmic design in addressing complex spatial problems.

The objective of the maze solver utilizing Breadth First Search (BFS) is to develop an efficient algorithm capable of determining the shortest path through a given maze. This algorithm takes a maze as input and systematically explores it using BFS until it reaches the endpoint. The output of this process includes not only the shortest path from the starting point to the endpoint but also the sequence of steps taken to achieve this route. This project holds significant relevance across diverse domains such as robotics, gaming, and navigation. For instance, in robotics, the ability to find the shortest path through a maze enables robots to navigate through complex environments and obstacles with optimal efficiency. Similarly, in gaming, this algorithm serves as a fundamental tool for guiding characters through various levels or scenarios, enhancing the gaming experience. Moreover, in navigation applications, the maze solver using BFS can be leveraged to identify the shortest route between two points on a map, facilitating efficient travel and logistics planning. Overall, the application of BFS-based maze solving algorithms extends to a wide array of practical scenarios, underscoring its importance in streamlining processes and enhancing decision-making across multiple fields.

The time complexity of the given code that converts an image of a maze into a 2D array and solves it using breadth-first search can be analyzed as follows:
1. Reading and manipulating the maze image file using the PIL library takes O(n) time, where n is the number of pixels in the image.
2. Converting the image into a 2D array takes O(n) time, as each pixel needs to be processed.
3. The breadth-first search algorithm used to solve the maze has a time complexity of. O (V + E), where V is the number of vertices (or cells) in the maze, and E is the number of edges (or paths) between those vertices. In the worst case, where the maze is a perfect grid and every cell is connected to its four neighbours, V = n and E = 2n - 2, giving a time complexity of O(n).
4. Drawing the output image using the PIL Image Draw library takes O(n) time, as each pixel needs to be processed.
Therefore, the overall time complexity of the code can be approximated as O(n) for large mazes.


